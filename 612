// 헤더 라인의 'rest'에서 Var 추출 (기존 파서와 동일한 규칙)
private string GetVarFromHeader(string sourceFile, string rest)
{
    // bracketRx: ^\[(?<tok>[^\]]+)\]\s*
    var tokens = new List<string>();
    string tmp = rest ?? "";
    int guard = 0;
    while (guard++ < 8)
    {
        var m = bracketRx.Match(tmp);
        if (!m.Success) break;
        tokens.Add(m.Groups["tok"].Value);
        tmp = tmp.Substring(m.Length);
    }

    string device = null, varName = null;
    if (tokens.Count >= 2) { device = tokens[0]; varName = tokens[1]; }
    else if (tokens.Count == 1) { varName = tokens[0]; }

    if (string.IsNullOrEmpty(device))
    {
        var n = Path.GetFileNameWithoutExtension(sourceFile);
        var cut = n.LastIndexOf('_');
        device = cut > 0 ? n.Substring(0, cut) : n;
    }
    if (string.IsNullOrEmpty(varName)) varName = device ?? "GLOBAL";
    return varName;
}


// 비즈명 → LOT 키 우선순위 (원하는 대로 추가/수정)
private static readonly Dictionary<string, string[]> lotKeyRules =
    new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase)
{
    { "BR_Slit",   new[] { "OUT_LOTID", "INPUT_LOTID" } },
    { "BR_Align",  new[] { "INPUT_CSTID" } },
    // … 계속 추가
};

// 규칙이 없는 비즈는 기본 우선순위(원치 않으면 배열 비워도 됨)
private static readonly string[] defaultLotKeys = new[] { "OUT_LOTID", "INPUT_LOTID", "INPUT_CSTID" };


// Success 블록에서 LOT 값 추출 (비즈명별 규칙 적용)
private string ExtractLotByBiz(string varName, string blockText)
{
    // 블록 안의 [n:KEY] : VALUE 라인들을 모두 수집
    var found = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
    using (var reader = new StringReader(blockText ?? ""))
    {
        string line;
        while ((line = reader.ReadLine()) != null)
        {
            var m = Regex.Match(line, @"^\s*\[\s*\d+\s*:\s*([A-Za-z0-9_]+)\s*\]\s*:\s*(.*)\s*$");
            if (m.Success)
            {
                var key = m.Groups[1].Value.Trim();
                var val = (m.Groups[2].Value ?? "").Trim();
                // 마지막 값으로 갱신하고 싶으면 무조건 대입, 최초만 원하면 ContainsKey 체크
                if (!found.ContainsKey(key)) found[key] = val;
                else found[key] = val; // (여러 번 나오면 마지막 값 우선으로 하려면 이 줄 유지)
            }
        }
    }

    // 비즈 규칙 적용
    if (!string.IsNullOrEmpty(varName) && lotKeyRules.TryGetValue(varName, out var keys))
    {
        foreach (var key in keys)
            if (found.TryGetValue(key, out var v) && !string.IsNullOrEmpty(v)) return v;
    }
    else
    {
        // 규칙 없는 비즈는 기본 키 우선순위
        foreach (var key in defaultLotKeys)
            if (found.TryGetValue(key, out var v) && !string.IsNullOrEmpty(v)) return v;
    }

    return string.Empty;
}



private void BuildLotIndexForFile(string fullPath)
{
    var source = Path.GetFileName(fullPath);
    var map = new Dictionary<int, string>();
    long idx = 0;

    int currentHeaderIdx = -1;
    bool inSuccessBlock = false;
    var sbBlock = new StringBuilder(1024);
    string currentVarName = null;

    using (var fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
    using (var sr = new StreamReader(fs, Encoding.UTF8, true, 1024 * 64))
    {
        string line;
        while ((line = sr.ReadLine()) != null)
        {
            var m = headRx.Match(line); // ^(?<dt>...) \[(?<level>...)\] (?<rest>.*)$
            if (m.Success)
            {
                // 이전 Success 블록 flush → LOT 인덱스 기록
                if (inSuccessBlock && currentHeaderIdx >= 0)
                {
                    var lot = ExtractLotByBiz(currentVarName, sbBlock.ToString());
                    if (!string.IsNullOrEmpty(lot)) map[currentHeaderIdx] = lot;
                }

                // 새 헤더 준비
                currentHeaderIdx = (int)idx;
                sbBlock.Clear();
                inSuccessBlock = (DetectKind(m.Groups["rest"].Value) == ActionKind.Success);

                // ★ 여기서 Var 뽑기 (기존 파서와 동일 규칙)
                currentVarName = GetVarFromHeader(source, m.Groups["rest"].Value);

                idx++;
                continue;
            }

            // 헤더가 아니면: 현재 Success 블록이면 누적
            if (inSuccessBlock) sbBlock.AppendLine(line);
            idx++;
        }
    }

    // 파일 끝에서도 마지막 Success 블록 flush
    if (inSuccessBlock && currentHeaderIdx >= 0)
    {
        var lot = ExtractLotByBiz(currentVarName, sbBlock.ToString());
        if (!string.IsNullOrEmpty(lot)) map[currentHeaderIdx] = lot;
    }

    lock (locker) { lotIndexByFile[source] = map; }
}
